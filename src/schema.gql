# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Token {
  chainId: Float!
  address: String!
  name: String!
  symbol: String!
  decimals: Float!
  logoUrl: String!
  nativeToken: Boolean!
  type: String!
  balance: String!
  balance24hAgo: String
  quote: Float
  prettyQuote: String
  quoteRate: Float
  quoteRate24hAgo: Float
}

type Attribute {
  trait_type: String!
  value: String!
}

type Nft {
  chainId: Float!
  address: String!
  name: String
  symbol: String
  balance: Int!
  supportsErc: [String!]!
  tokenId: String!
  nftName: String
  description: String
  image: String
  animationUrl: String
  attributes: [Attribute]
}

type TransactionData {
  from: String!
  to: String!
  data: String!
  value: String!
  gasPrice: String!
  gasLimit: String!
}

type ValhaIneractionData {
  approveTx: [TransactionData!]!
  interactionTx: TransactionData!
}

type BridgeAsset {
  chainId: Int!
  address: String!
  symbol: String!
  name: String!
  decimals: Int!
  icon: String!
  logoURI: String!
  chainAgnosticId: String
}

type BridgeRoute {
  routeId: String!
  isOnlySwapRoute: Boolean!
  fromAmount: String!
  toAmount: String!
  usedBridgeNames: [String!]!
  minimumGasBalances: JSON!
  chainGasBalances: JSON!
  totalUserTx: Int!
  sender: String!
  recipient: String!
  totalGasFeesInUsd: Float!
  receivedValueInUsd: Float!
  inputValueInUsd: Float!
  outputValueInUsd: Float!
  userTxs: [JSON!]!
  serviceTime: Int!
  maxServiceTime: Int!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type BridgeQuote {
  routes: [BridgeRoute!]!
  fromAsset: BridgeAsset!
  toAsset: BridgeAsset!
}

type BridgeApprovalData {
  data: String!
  to: String!
  from: String!
}

type BridgeBuildTxDataWithApproveData {
  userTxType: String!
  txData: String!
  txTarget: String!
  chainId: String!
  value: String!
  userTxIndex: Int!
  approvalData: BridgeApprovalData
  needApproval: Boolean!
}

type BridgeSupportedToken {
  name: String
  address: String!
  chainId: Int!
  decimals: Int!
  symbol: String!
  logoUri: String!
  chainAgnosticIc: String!
}

type Source {
  name: String!
  proportion: String!
}

type FillData {
  tokenAddressPath: [String!]!
  router: String!
}

type Order {
  makerToken: String!
  takerToken: String!
  makerAmount: String!
  takerAmount: String!
  fillData: FillData!
  source: String!
  sourcePathId: String!
  type: Int!
}

type SwapQuote {
  chainid: Int!
  price: String!
  guaranteedPrice: String!
  to: String!
  data: String!
  value: String!
  expectedSlippage: String
  buyTokenAddress: String!
  buyAmount: String!
  sellTokenAddress: String!
  sellAmount: String!
  sources: [Source!]!
  orders: [Order!]!
  AllownaceTarget: String!
}

type SwapPrice {
  chainid: Int!
  price: String!
  value: String!
  buyTokenAddress: String!
  buyAmount: String!
  sellTokenAddress: String!
  sellAmount: String!
  gas: String!
  AllownaceTarget: String!
}

type Query {
  findEvmTokenBalance(address: String!, chainIds: [Int!]!, quoteCurrency: QuoteCurrency!): [Token!]!
  findEvmNftBalance(address: String!, chainIds: [Int!]!): [Nft!]!
  valhaZapTransaction(valhaZapInput: ValhaZapInput!): ValhaIneractionData!
  findBridgeSupportedFromTokens(fromChainId: Int!, toChainId: Int!): [BridgeSupportedToken!]!
  findBridgeSupportedToTokens(fromChainId: Int!, toChainId: Int): [BridgeSupportedToken!]!
  findBridgeQuote(fromChainId: Int!, fromTokenAddress: String!, toChainId: Int!, toTokenAddress: String!, fromAmount: String!, userAddress: String!, sort: String!, isContractCall: Boolean!, defaultSwapSlippage: Float!, recipient: String): BridgeQuote!
  findBridgeRouteTransactionData(route: BridgeRouteInput!): BridgeBuildTxDataWithApproveData!
  findApprovalTransactionData(approvalDataInput: BridgeBuildTxApprovalDataInput!): BridgeApprovalData!
  findSwapQuote(chainId: Int!, sellToken: String!, buyToken: String!, sellAmount: String, buyAmount: String, slippagePercentage: String, takerAddress: String): SwapQuote!
  findSwapPrice(chainId: Int!, sellToken: String!, buyToken: String!, sellAmount: String, buyAmount: String, takerAddress: String): SwapPrice!
}

enum QuoteCurrency {
  USD
  CAD
  EUR
  SGD
  INR
  JPY
  VND
  CNY
  KRW
  RUB
  TRY
  NGN
  ARS
  AUD
  CHF
  GBP
}

input ValhaZapInput {
  chainId: Int!
  walletAddress: String!
  poolAddress: String!
  action: String!
  inputAmount: Float!
  disableCheck: Boolean!
  useValhaRouter: Boolean!
  swapProvider: String!
  swapToken: String!
}

input BridgeRouteInput {
  routeId: String!
  isOnlySwapRoute: Boolean!
  fromAmount: String!
  toAmount: String!
  usedBridgeNames: [String!]!
  minimumGasBalances: JSON!
  chainGasBalances: JSON!
  totalUserTx: Int!
  sender: String!
  recipient: String!
  totalGasFeesInUsd: Float!
  receivedValueInUsd: Float!
  inputValueInUsd: Float!
  outputValueInUsd: Float!
  userTxs: [JSON!]!
  serviceTime: Int!
  maxServiceTime: Int!
}

input BridgeBuildTxApprovalDataInput {
  chainId: Int!
  minimumApprovalAmount: String!
  approvalTokenAddress: String!
  allowanceTarget: String!
  owner: String!
}